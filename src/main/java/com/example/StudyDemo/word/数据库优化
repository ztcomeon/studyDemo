数据库优化的几个阶段
第一阶段 优化sql和索引
第二阶段 搭建缓存
第三阶段 读写分离
第四阶段 利用分区表
第五阶段 垂直拆分
第六阶段 水平拆分
https://www.cnblogs.com/rjzheng/p/9619855.html
=============================================================
第一阶段 优化sql和索引
	成本最低，索引优化和SQL优化  步骤：
	(1)用慢查询日志定位执行效率低的SQL语句
	(2)用explain分析SQL的执行计划
	(3)确定问题，采取相应的优化措施，建立索引啊，等

第二阶段 搭建缓存
	在优化sql无法解决问题的情况下，才考虑搭建缓存
	使用缓存的目的，就是将复杂的、耗时的、不常变的执行结果缓存起来，降低数据库的资源消耗。
	缓存和数据库一致性问题？(比如是更缓存，还是删缓存)
	缓存击穿、缓存穿透、缓存雪崩问题如何解决？是否有做缓存预热的必要。

第三阶段 读写分离
	搞主从复制，上读写分离，在应用层，区分读写请求，或者利用现成的中间件mycat或者altas等做读写分离
	(1)主从的好处？
		回答:实现数据库备份，实现数据库负载均衡，提交数据库可用性

	(2)主从的原理?
		主库有一个log dump线程，将binlog传给从库
		从库有两个线程，一个I/O线程，一个SQL线程
		I/O线程读取主库传过来的binlog内容并写入到relay log
		SQL线程从relay log里面读取内容，写入从库的数据库。

	(3)如何解决主从一致性?
		我不建议在数据库层面解决该问题。根据CAP定理，主从架构本来就是一种高可用架构，是无法满足一致性的
		哪怕你采用同步复制模式或者半同步复制模式，都是弱一致性，并不是强一致性。
		所以，推荐还是利用缓存，来解决该问题。
			1、自己通过测试，计算主从延迟时间，
			2、数据库的写操作，先写数据库，再写cache，但是有效期很短，就比主从延时的时间稍微长一点。
			3、读请求的时候，先读缓存，缓存不存在(这时主从同步已经完成)，再读数据库。

第四阶段 利用分区表
	因为很多互联网公司都不建议用分区表，我自己也不太建议用分区表，采用这个分区表，坑太多。

第五阶段 垂直拆分
	垂直拆分的复杂度还是比水平拆分小的。将你的表，按模块拆分为不同的小表。
	拆分原则一般是如下三点:
		(1)把不常用的字段单独放在一张表。
		(2)把常用的字段单独放一张表
		(3)经常组合查询的列放在一张表中（联合索引）。

第六阶段 水平拆分
	水平拆分是最麻烦的一个阶段，拆分后会有很多的问题，我再强调一次，水平拆分一定是最最最最后的选择。
	水平拆分模块间耦合性太强，成本太大，不是特别推荐




