问题：
(1)HashMap的实现原理?
	你看过HashMap源码嘛，知道原理嘛?
	为什么用数组+链表？
	hash冲突你还知道哪些解决办法？
	我用LinkedList代替数组结构可以么?
	既然是可以的,为什么HashMap不用LinkedList,而选用数组?
	那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList?
(2)HashMap在什么条件下扩容?
	HashMap在什么条件下扩容?
	为什么扩容是2的n次幂?
	为什么为什么要先高16位异或低16位再取模运算?
(3)讲讲hashmap的get/put的过程?
	知道hashmap中put元素的过程是什么样么?
	知道hashmap中get元素的过程是什么样么？
	你还知道哪些hash算法？
	说说String中hashcode的实现?(此题很多大厂问过)
(4)为什么hashmap的在链表元素数量超过8时改为红黑树?
	知道jdk1.8中hashmap改了啥么?
	为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?
	我不用红黑树，用二叉查找树可以么?
	那为什么阀值是8呢?
	当链表转为红黑树后，什么时候退化为链表?
(5)HashMap的并发问题?
	HashMap在并发编程环境下有什么问题啊?
	在jdk1.8中还有这些问题么?
	你一般怎么解决这些问题的？
(6)你一般用什么作为HashMap的key?
	健可以为Null值么?
	你一般用什么作为HashMap的key?
	我用可变类当HashMap的key有什么问题?
	如果让你实现一个自定义的class作为HashMap的key该如何实现？

=============================================================
https://www.cnblogs.com/rjzheng/p/11302835.html
(1)HashMap的实现原理?
	你看过HashMap源码嘛，知道原理嘛?
		entry数组存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构
		它具有Next指针，可以连接下一个Entry实体。（entry实体，键值对链表）
		只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！

	为什么用数组+链表？
		数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到.（数组定位，链表解决冲突）
		链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。

	hash冲突你还知道哪些解决办法？
		(1)开放定址法(2)链地址法（拉链法）(3)再哈希法(4)公共溢出区域法
		数据结构中有1和2，开放定址法：将冲突的存放在空闲地址处，四种方法：
		线性探测法，平方探测法，再散列法，伪随机数法

	我用LinkedList代替数组结构可以么?
		可以的。

	既然是可以的,为什么HashMap不用LinkedList,而选用数组?
		数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到，
		我们已得到桶的位置。显然数组的查找效率比LinkedList大（先求位置，然后根据位置来存取，数组最快）

	那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList?
		基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高
		ArrayList的扩容机制是1.5倍扩容（数组能够自定义扩容机制）

(2)HashMap在什么条件下扩容?
	HashMap在什么条件下扩容?
		如果bucket满了(超过load factor*current capacity)，就要resize。这里的满不是全装满，而是
		当前数组大小*load factor，load factor为0.75，为了最大程度避免哈希冲突，数组默认大小是16

	为什么扩容是2的n次幂?
		要尽量较少碰撞，就是要尽量把数据分配均匀， 这个算法实际就是取模，hash%length。
		大家都知道这种运算不如位移运算快。因此，源码中做了优化hash&(length-1)。
		hash%length==hash&(length-1)2的n次方实际就是1后面n个0，2的n次方-1，实际就是n个1

	为什么为什么要先高16位异或低16位再取模运算?
		了降低hash冲突的几率，具体的话可以在网上再看看

(3)讲讲hashmap的get/put的过程?
	知道hashmap中put元素的过程是什么样么?
		对key的hashCode()做hash运算，计算index;如果没碰撞直接放到bucket里；
		如果碰撞了，以链表的形式存在buckets后；如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD=8）
		就把链表转换成红黑树(JDK1.8中的改动)；如果节点已经存在就替换old value(保证key的唯一性)
		如果bucket满了(超过load factor*current capacity=当前容量*0.75)，就要resize。

	知道hashmap中get元素的过程是什么样么？
		对key的hashCode()做hash运算，计算index;
		如果在bucket里的第一个节点里直接命中，则直接返回；
		如果有冲突，则通过key.equals(k)去查找对应的Entry;
			若为树，则在树中通过key.equals(k)查找，O(logn)
			若为链表，则在链表中通过key.equals(k)查找，O(n)

	你还知道哪些hash算法？
		Hash函数是指把一个大范围映射到一个小范围，节省空间，使得数据容易保存
		比较出名的有MurmurHash、MD4、MD5等等

	说说String中hashcode的实现?(此题很多大厂问过)：：不是很理解
		就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模
		哈希计算公式可以计为s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
		那为什么以31为质数呢?主要是因为31是一个奇质数，
		所以31*i=32*i-i=(i<<5)-i，这种位移与减法结合的计算相比一般的运算快很多

(4)为什么hashmap的在链表元素数量超过8时改为红黑树?
	知道jdk1.8中hashmap改了啥么?
		由数组+链表的结构改为数组+链表+红黑树。
		优化了高位运算的hash算法：h^(h>>>16)
		扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。
		最后一条是重点，因为最后一条的变动，hashmap在1.8中，不会在出现死循环问题。

	为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?
		因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。
		当元素小于8个当时候，此时做查询操作，链表结构已经能保证查询性能
		当元素大于8个的时候，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了
		因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。

	我不用红黑树，用二叉查找树可以么?
		可以。但是二叉查找树在特殊情况下会变成一条线性结构，遍历查找会非常慢。（数据结构）

	那为什么阀值是8呢?
		不知道，等jdk作者来回答。（jdk作者选择8，一定经过了严格的运算，觉得在长度为8的时候
		与其保证链表结构的查找开销，不如转换为红黑树，改为维持其平衡开销）多半是性能问题

	当链表转为红黑树后，什么时候退化为链表?
		为6的时候退转为链表，中间有个差值7可以防止链表和树之间频繁的转换，
		如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，
		就会频繁的发生树转链表、链表转树，效率会很低

(5)HashMap的并发问题?
	HashMap在并发编程环境下有什么问题啊?
		(1)多线程扩容，引起的死循环问题（先记结论吧，具体细节网上再看）
		(2)多线程put的时候可能导致元素丢失
		(3)put非null元素后get出来的却是null

	在jdk1.8中还有这些问题么?
		在jdk1.8中，死循环问题已经解决。其他两个问题还是存在。

	你一般怎么解决这些问题的？
		比如ConcurrentHashmap，Hashtable等线程安全等集合类。

(6)你一般用什么作为HashMap的key?
	键可以为Null值么?
		必须可以，key为null的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置

	你一般用什么作为HashMap的key?
		一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。（注意不可变类）
		)因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算
		)因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的

	我用可变类当HashMap的key有什么问题?
		hashcode可能发生改变，导致put进去的值，无法get出

	如果让你实现一个自定义的class作为HashMap的key该如何实现？
		重写hashcode和equals方法注意什么?
		如何设计一个不变类，记住如何写一个不可变类
		(1)类添加final修饰符，保证类不被继承。
		(2)保证所有成员变量必须私有，并且加上final修饰
		(3)不提供改变成员变量的方法，包括setter
		(4)通过构造器初始化所有成员，进行深拷贝(deep copy)
		(5)在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝








