
敖丙
课代表帮你的总结知识点.pdf

redis的各个知识点的xmind

----
应用场景：
    1.秒杀库存扣减
    2.app首页的访问流量高峰
    3.与memoCache的区别

基础知识：
    数据结构：
        1.五种基础的数据结构：String，Hash，List，Set，SortedSet
        2.其他的数据结构：HyperLogLog，Geo，Pub\Sub
        3.用于防止缓存击穿的数据结构：Redis Module，像BloomFilter，RedisSearch，Redis-ML
        4.设置key值过期：setRedis（Key，value，time+MathRandom()*10000）:expire:
    分布式锁：
        1.先拿setnx来争抢锁，争抢到之后，再用expire给锁加一个过期时间，防止锁忘记释放
        2.如果在setnx之后，expire之前，进程意外crash或需要重启维护，需要把setnx和expire合成一条指令来用
    keys命令：
        1.redis是单线程的，keys命令会导致线程阻塞一段时间，线上的服务会出现停顿，直到命令执行完毕才会恢复
        2.scan指令能够无阻塞的提取出指定模式的key，但是会有一定概率的重复，需要在客户端做一次去重，但是整体
          花费的时间比keys指令的长（scan代替keys指令，本质是执行多次keys）
        3.smembers可以返回集合键当前包含的所有元素
        4.scan之类增量式迭代命令来说，因为是对键进行增量式迭代过程中，键可能会被修改，所以增量式迭代命令
          只能对返回的元素提供有限的保证。（大概就是：scan是先0-10在10-20在20-30这样去keys）
    异步队列：
        1.list结构作为队列，rpush生成消息，lpop消费消息，当lpop没有消息的时候，需要sleep一会在重试
        2.list还有个指令叫做blpop在没有消息的时候，它会阻塞住，直到消息到来
        3.pub/sub主题订阅者模式，可以实现1：N的消息队列实现生成一次，消费多次
        4.pub/sub主题订阅者模式，消费者下线的情况下，生产的消息会丢失，所以要使用专业的消息队列
    延迟队列：
        1.sortedset拿时间戳来做为score，消息内容做为key，调用zadd来生产消息，消费者用zrangbyscore指令
          获取N秒前的数据轮询进行处理
    持久化：
        1.rdb做镜像全量持久化，aof做增量持久化，因为rdb比较耗时，不够实时，在停机的时候会导致大量的数据丢失
          所以需要aof来配合，在redis实例重启时，会使用rdb持久化文件重新构建内存，在使用aof重放最近的操作指令
          来实现完整的恢复到重启之前的状态
        2.redis本身的机制是，aof持久化开启且存在aof文件的时候，优先加载aof文件，aof关闭或者aof不存在时，
          加载rdb文件，加载aof/rdb文件后，redis启动成功，aof/rdb文件存在错误时，redis启动失败并打印错误信息
    机器断电对数据丢失的影响：
        1.aof日志sync属性的配置，如果不要求性能，在每条写指令时，都会sync一下磁盘，就不会丢失数据，但是在高
          性能的要求下每次写都sync是不现实的，一般都是使用定时sync，比如1秒1次，这个时候最多丢失1s的数据
    rdb原理：
        1.fork是指redis通过创建子进程来进行rdb操作（写入一个临时RDB文件），cow指的是copy on write，子进程创建后，
          父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来
    Pipeline好处：
        1.可以将多次往返的IO时间压缩为一次，前提是pipeline执行的指令之间没有因果相关性
    集群的同步机制：
        1.redis可以使用主从同步，从从同步
        2.第一次同步的时候，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件
          全量同步到复制节点
        3.复制节点接收完成后，将rdb镜像加载到内存，加载完毕后，在通知主节点
        4.后续的增量数据通过aof日志同步即可，有点类似数据库的binlog
    集群的高可用：
        1.redis sentinal着眼于高可用，在master宕机的时候，会自动将slave提升为master，然后继续提供服务
        2.redis cluster着眼于扩展性，在当个redis内存不足的时候，使用cluster进行分片存储

缓存雪崩，击穿，穿透：
    雪崩：
        1.大面积的缓存失效，打崩了DB
        2.同一时间大面积失效，那一瞬间redis等于没有，这个数量级的请求直接打在DB上面，是灾难级别的，如果打挂
          一个用户服务的库，那么其他依赖这个库的接口都会报错，如果没有做熔断策略，那么将会挂一片服务
        3.解决方法：
          1.批量往redis中存数据的时候，把每一个key的失效时间都加一个随机值，保证key不会在某一时间大面积失效
          2.redis是集群部署，将热点数据均匀分布在不同redis库中，也能避免全部同时失效的问题
          3.设置热点数据不过期，有更新操作就更新缓存就行
    击穿：
        1.一个key非常的热点，不停的在抗大并发，大并发集中对这一个点进行访问，当这个key失效的瞬间，持续的大并发
          就会击穿缓存，直接请求数据库
        2.解决方法：
          1.设置热点数据永不过期
          2.增加互斥锁
    穿透：
        1.用户不断发起缓存和数据库中都不存在的数据的请求，导致数据库压力过大，严重可能会击垮数据库
        2.解决方法：
          1.增加数据的校验
          2.从网关层Nginx增加配置项，对单IP每秒访问次数超过阈值的IP进行拉黑等限制
          3.布隆过滤器（Bloom Filter）这个也能很好的防止缓存穿透的发生，他的原理就是利用高效的数据结构和算法
            来判断你这个key是否在数据库中，不存在就直接return，存在就从数据库中取，然后刷新到缓存在return

持久化：
    RDB：
        1.冷备
        2.RDB持久化机制，是对redis中的数据进行周期性的持久化
        3.优点：RDB对redis的性能影响很小，是因为在同步数据的时候，fork了一个子进程去进行持久化，而且他在数据
               恢复时的速度比AOF快（copy on write 主进程更新时会复制那个需要更新的页到自己进程中）
        4.缺点：RDB是都是快照文件，是默认五分钟或者更久才生成一次，这意味着这次同步到下次同步的五分钟期间的数据
               可能会丢失，AOF则最多丢失一秒的数据，RDB在生成快照的时候，如果文件很大，客户端会暂停几毫秒或几秒
    AOF：
        1.热备
        2.AOF对每条写入命令作为日志，以append-only模式写入到一个日志文件中
        3.优点：AOF是一秒一次通过后台的线程fsync操作，那最多丢失这一秒的数据，AOF对日志进行操作的时候是以append
               -only方式去写的，他知识追加的方式写数据，自然就少了很多磁盘寻址的开销
        4.缺点：一样的数据，AOF文件比RDB大（还有启动慢吧）

哨兵：
    1.哨兵+主从：实现redis的集群高可用
    2.集群监控：负责监控redis的master和slave进程是否正常工作
    3.消息通知：如果某个redis实例发生故障，则哨兵负责发送消息作为报警通知给管理员
    4.故障转移：如果master node挂了，会自动转移到slave node上
    5.配置中心：如果故障转移发生了，通知client客户端新的master地址

主从同步：
    1.启动一台slave时，他会发送一个psync命令给master，如果这个slave是第一次连接到这个master，则会触发一个
      全量复制，master会启动一个线程，生成RDB快照，还会把新的写请求都缓存到内存中，rdb文件生成后，master
      会把这个文件发送给slave，slave拿到之后第一时间就写入到本地磁盘中，然后加载到内存中，然后master会把内存
      中的这期间产生的新命令发送给slave

内存淘汰机制（过期策略）：
    1.定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行键的删除
    （redis使用定期+惰性，不用定时删除的原因是，定时比较消耗cpu）
    2.惰性删除：不管键的过期，在从键空间获取键的时候，都会先检查键是否过期，如果过期，删除，没过期，返回
    3.定期删除：每隔一段时间（100ms）就随机抽取一些设置了过期时间的键进行检查，如果过期就删除

分布式锁：
    1.基于zookeeper实现分布式锁，每个系统通过zookeeper获取分布式锁，确保同一时间，只能有一个系统实例在操作某个
      key，解决多个系统同时操作redis带来的数据问题

最经典的KV，DB读写模式：
    缓存+数据库的读写模式：
        1.读的时候，先读缓存，缓存没有的时候再去读数据库，读出数据后放入缓存，同时返回响应
        2.更新的时候，先更新数据库，在删除缓存

与memcached区别：
    1.redis的数据结构更加丰富，能支持更丰富的数据操作
    2.redis3.x版本中，支持cluster模式，而memcached没有原生的集群模式，需要依赖客户端实现往集群中分片写入数据
    3.redis只使用单核，而memcached可以使用多核，所以平均每一个核redis存储小数据时比memcached性能要好很多

学习思路：
    1.事前：redis高可用，主从+哨兵，redis cluster，避免全面崩盘
    2.事中：本地ehcache缓存+hystix限流+降级，避免mysql被打死
    3.事后：redis持久化rdb+aof，一旦重启，自动从磁盘上面加载数据，快速恢复缓存数据

==============================================================================================
