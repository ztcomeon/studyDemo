分库分表后如何部署上线

总结：两种方法
停机部署法：简单
双写部署法：不停机，稍微复杂点，需要使用消息队列或者binlog，订阅程序去取更新最新的消息
=======================
https://www.cnblogs.com/rjzheng/p/9597810.html

网上很多分库分表的文章，但是很少有写之后怎么部署

停机部署法
	大致思路就是，挂一个公告，半夜停机升级，然   后半夜把服务停了，跑数据迁移程序，进行数据迁移。
步骤如下:
(1)出一个公告，比如“今晚00:00～6:00进行停机维护，暂停服务”
(2)写一个迁移程序，读db-old数据库，通过中间件写入新库db-new1和db-new2，具体如下图所示
(3)校验迁移前后一致性，没问题就切该部分业务到新库。

顺便科普一下，这个中间件。现在流行的分库分表的中间件有两种，一种是proxy（代理）形式的，例如mycat，
是需要额外部署一台服务器的。
还有一种是client形式的，例如当当出的Sharding-JDBC，就是一个jar包，使用起来十分轻便
这种方式，无需额外部署，无其他依赖，DBA也无需改变原有的运维方式。

这几个问题可以参考一下其他博客
你们怎么进行分库分表的？
	回答这个问题建议自己主动把分表的策略，以及如何部署的方法讲出来。

分表有哪些策略啊？你们用哪种啊？
	具体指向了分库分表的某个方向

双写部署法(一)
	这个就是不停机部署法，这里我需要先引进两个概念:历史数据和增量数据。
我们是对一张叫做test_tb的表进行拆分，因为你要进行双写，系统里头和test_tb表有关的
业务之前必定会加入一段双写代码，同时往老库和新库中写，然后进行部署

	历史数据:在该次部署前，数据库表test_tb的有关数据，我们称之为历史数据。
	增量数据:在该次部署后，数据库表test_tb的新产生的数据，我们称之为增量数据。

然后迁移流程如下
	(1)先计算你要迁移的那张表的max(主键)。在迁移过程中，只迁移db-old中test_tb表里，
	主键小等于该max(主键)的值，也就是所谓的历史数据。
	这里有特殊情况，如果你的表用的是uuid，没法求出max(主键)，那就以创建时间作为划分历史数据
	和增量数据的依据
	(2)在代码中，与test_tb有关的业务多加一条往消息队列中发消息的代码，将操作的sql发送到消息队列中，
	至于消息体如何组装，大家自行考虑，注意：只发写请求的sql
	等到db-old中的历史数据迁移完毕，则开始迁移增量数据，也就是在消息队列里的数据。
	(4)将迁移程序下线，写一段订阅程序订阅消息队列中的数据
	(5)订阅程序将订阅到到数据，通过中间件写入新库
	(6)新老库一致性验证，去除代码中的双写代码，将涉及到test_tb表的读写操作，指向新库。

这里大家可能会有一个问题，在步骤(1)～步骤(3),系统对历史数据进行操作，会造成不一致的问题么？
OK，不会。这里我们对delete操作和update操作做分析，因为只有这两个操作才会造成历史数据变动，
insert进去的数据都是属于增量数据。
(1)对db-old的test_tb表的历史数据发出delete操作，数据还未删除，就被迁移程序给迁走了。
此时delete操作在消息队列里还有记录，后期订阅程序订阅到该delete操作，可以进行删除。
(2)对db-old的test_tb表的历史数据发出delete操作，数据已经删除，迁移程序迁不走该行数据。此时delete操作
在消息队列里还有记录，后期订阅程序订阅到该delete操作，再执行一次delete，并不会对一致性有影响。
对update的操作类似，不赘述。

双写部署法(二)
上面的方法有一个硬伤：入侵业务代码，会造成很大的不方便，所以上面的操作不是很可行
(2)在代码中，与test_tb有关的业务，多加一条往消息队列中发消息的代码，将操作的sql发送到消息队列中
大家想一下，这么做，是不是造成了严重的代码入侵。将非业务代码嵌入业务代码，这么做，
后期删代码的时候特别累。有没什么方法，可以避免这个问题的?

解决方法，订阅binlog日志。关于binlog日志
记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）
的二进制日志。binlog不会记录SELECT和SHOW这类操作，因为这类操作对据本身并没有修改。
双写部署法(一)里介绍的，往消息队列里发的消息，都是写操作的消息。而binlog日志记录的也是写操作。
所以订阅该日志，也能满足我们的需求。步骤：
(1)打开binlog日志，系统正常上线就好
(2)还是写一个迁移程序，迁移历史数据。步骤和上面类似，不啰嗦了。
(3)写一个订阅程序，订阅binlog(mysql中有canal，然后将订阅到到数据通过中间件，写入新库。
(4)检验一致性，没问题就切库。

怎么验数据一致性：
这里大概介绍一下吧，这篇的篇幅太长了，大家心里有底就行。
(1)先验数量是否一致，因为验数量比较快。
至于验具体的字段，有两种方法:
(2.1)有一种方法是，只验关键性的几个字段是否一致。
(2.2)还有一种是 ，一次取50条(不一定50条，具体自己定，我只是举例),然后像拼字符串一样，拼在一起。
	用md5进行加密，得到一串数值。新库一样如法炮制，也得到一串数值，比较两串数值是否一致。
	如果一致，继续比较下50条数据。如果发现不一致，用二分法确定不一致的数据在0-25条，还是26条-50条
	以此类推，找出不一致的数据，进行记录即可。








