
select相关
外键
事务
互联网项目使用的隔离级别
====================================
Mysql中select的正确姿势

https://www.cnblogs.com/rjzheng/p/9902911.html
关于：
select * from table						不推荐这种方法，主要是网络IO问题
select col1,col2,...,coln from table	推荐这种方法，不过性能实际和上面差不多（查询全部字段的时候）
区别
《SQL CookBook》第一章 检索记录中1.1小节（原书第十五页内容如下）：
此书也说明了，两种方式在性能上几乎是没有差距的。

那为什么还是不推荐select * ? 三个方面 ： 网络IO，索引，扩展性

网络IO问题
	要原因是带来了额外的网络开销。
	select *会查询出不需要的、额外的数据，那么这些额外的数据在网络上进行传输，必定会造成性能延迟。
	假设你的table中，有一个列的类型为binary。此时，你的select *操作，就会十分缓慢，并且会造成额外的网络开销。

索引问题
	仔细看下面的两句sql
	select col1 from table;
	select * from table;
	如果col1字段包含索引信息，那么此时，这两句的sql执行时间可能会有几十上百倍的差异。
	在col1字段有索引的情况下，mysql是可以不用读data，直接使用index里面的值就返回结果的。
	但是一旦用了select *，就会有其他列需要读取，这时在读完index以后还需要去读data才会返回结果。

扩展性问题
	select 指定列，只获取自己需要的几列，表结构的修改，对你代码的影响就会小很多，可读性更强。

========================================================================================================
数据库中为什么不推荐使用外键约束
https://www.cnblogs.com/rjzheng/p/9907304.html
在阿里的JAVA规范中也有下面这一条：
【强制】不得使用外键与级联，一切外键概念必须在应用层解决。

外键约束是一种约束，这个约束的存在，会保证表间数据的关系“始终完整”，外键优点：
	保证数据的完整性和一致性
	级联操作方便
	将数据完整性判断托付给了数据库完成，减少了程序的代码量

外键是能够保证数据的完整性，但是会给系统带来很多缺陷。
性能问题：
	假设一张表名为user_tb。那么这张表里有两个外键字段，指向两张表。那么，每次往user_tb表里插入数据，
	就必须往两个外键对应的表里查询是否有对应数据。如果交由程序控制，这种查询过程就可以控制在我们手里，
	可以省略一些不必要的查询过程。但是如果由数据库控制，则是必须要去这两张表里判断。

并发问题：
	在使用外键的情况下，每次修改数据都需要去另外一个表检查数据,需要获取额外的锁。
	是在高并发大流量事务场景，使用外键更容易造成死锁。

扩展性问题：
	做平台迁移方便：比如你从Mysql迁移到Oracle，像触发器、外键这种东西，都可以利用框架本身的特性来实现，
		而不用依赖于数据库本身的特性，做迁移更加方便。
	分库分表方便：在水平拆分和分库的情况下，外键是无法生效的。将数据间关系的维护，放入应用程序中，
		为将来的分库分表省去很多的麻烦。

技术问题：
	使用外键，其实将应用程序应该执行的判断逻辑转移到了数据库上。那么这意味着一点，数据库的性能开销变大了，
	那么这就对DBA的要求就更高了。选择不用外键，可以降低数据库的消耗。
	该约束逻辑在应用程序中，发现应用服务器性能不够，可以加机器，做水平扩展。
	如果是在数据库服务器上，数据库服务器会成为性能瓶颈，做水平扩展比较困难。

======================================================================================
新说Mysql事务隔离级别
https://www.cnblogs.com/rjzheng/p/9955395.html

说说事务的隔离级别吧？
可重复读(Repeatable Read)是否真的解决幻读的问题！

根据事务的隔离级别不同，会有三种情况发生。即脏读、不可重复读、幻读。
根据脏读、不可重复读、幻读定义来看(自己总结，官网没有)，有如下包含关系:
幻读>不可重复读>脏读
即，如果发生了脏读，那么不可重复读和幻读是一定发生的。因为拿脏读的现象，用不可重复读，幻读的定义也能解释的通。
但是反过来，拿不可重复读的现象，用脏读的定义就不一定解释的通了！
	脏读：一个事务读到了另一个事务未提交的数据
	不可重复读：一个事务对一个数据读取了两次的结果不同，事务1查询两次结果不同，事务2对结果进行了修改（内容变化）
	幻读：事务1查询两次结果不同，事务2对结果进行了新增或者删除（数量上的变化）

1、读未提交(READ_UNCOMMITTED)
	其实这个从隔离名字就可以看出来，一个事务可以读到另一个事务未提交的数据！
	根据我们最开始的推理，如果存在脏读，那么不可重复读和幻读一定是存在的。

2、读已提交(READ_COMMITTED)
	这个也能看的出来，一个事务能读到另一个事务已提交的数据（可以解决脏读）

3、可重复读(REPEATABLE_READ)
	可以解决脏读，不可重复读，是mysql的默认隔离级别

4、串行读(SERIALIZABLE_READ)
	可以解决脏读，不可重复读，幻读

================================================================
互联网项目中mysql应该选什么事务隔离级别
https://www.cnblogs.com/rjzheng/p/10510174.html

互联网项目的隔离级别：读已提交(Read Commited)！

在Oracle，SqlServer中都是选择读已提交(Read Commited)作为默认的隔离级别，
为什么Mysql不选择读已提交(Read Commited)作为默认隔离级别，而选择可重复读(Repeatable Read)作为默认的隔离级别呢？
这个是有历史原因的，当然要从我们的主从复制开始讲起了！
主从复制，是基于什么复制的？
是基于binlog复制的！这里不想去搬binlog的概念了，就简单理解为binlog是一个记录数据库更改的文件吧～
binlog有几种格式？
三种，分别是：
	statement:记录的是修改SQL语句
	row：记录的是每行实际数据的变更
	mixed：statement和row模式的混合
那Mysql在5.0这个版本以前，binlog只支持STATEMENT这种格式！而这种格式在读已提交(Read Commited)这
个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别！
当binlog为STATEMENT格式，且隔离级别为读已提交(Read Commited)时，有什么bug呢？
模拟两个事务操作：
就是在master上执行的顺序为先删后插！而此时binlog为STATEMENT格式，它记录的顺序为先插后删！

如何解决？
解决方案有两种！
(1)隔离级别设为可重复读(Repeatable Read)：
	在该隔离级别下引入间隙锁。当Session 1执行delete语句时，会锁住间隙。那么，Ssession 2执行插入语句就会阻塞住！
(2)将binglog的格式修改为row格式，
	此时是基于行的复制，自然就不会出现sql执行顺序不一样的问题！奈何这个格式在mysql5.1版本开始才引入。
	因此由于历史原因，mysql将默认的隔离级别设为可重复读(Repeatable Read)，保证主从复制不出问题！

当我们了解完mysql选可重复读(Repeatable Read)作为默认隔离级别的原因后，接下来我们将其和
读已提交(Read Commited)进行对比，来说明为什么在互联网项目为什么将隔离级别设为读已提交(Read Commited)！

为了便于描述，下面将
可重复读(Repeatable Read)，简称为RR；
读已提交(Read Commited)，简称为RC；

缘由一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！
	此时执行语句
	select * from test where id <3 for update;
	在RR隔离级别下，存在间隙锁，可以锁住(2,5)这个间隙，防止其他事务插入数据！
	而在RC隔离级别下，不存在间隙锁，其他事务是可以插入数据！
	ps:在RC隔离级别下并不是不会出现死锁，只是出现几率比RR低而已！

缘由二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行
	update test set color = 'blue' where color = 'white';
	在RC隔离级别下，其先走聚簇索引，进行全部扫描。
	但在实际中，MySQL做了优化，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁。
	此时只有满足条件的行才会加锁

	然而，在RR隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上，

缘由三：在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！
	在5.1.15的时候，innodb引入了一个概念叫做“semi-consistent”，减少了更新同一行记录时的冲突，减少锁等待。
	所谓半一致性读就是，一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，
	由MySQL上层判断此版本是否满足update的where条件。
	若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)！
	具体表现如下:
	此时有两个Session，Session1和Session2！
	Session1执行
	update test set color = 'blue' where color = 'red';
	先不Commit事务！
	与此同时Ssession2执行
	update test set color = 'blue' where color = 'white';
	session 2尝试加锁的时候，发现行上已经存在锁，InnoDB会开启semi-consistent read，返回最新的committed版本(1,red),
	(2，white),(5,red),(7,white)。MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)!

两个疑问
	在RC级别下，不可重复读问题需要解决么？
		不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！
		Oracle的默认隔离级别就是RC，你们改过Oracle的默认隔离级别么？

	在RC级别下，主从复制用什么binlog格式？
		在该隔离级别下，用的binlog为row格式，是基于行的复制！

