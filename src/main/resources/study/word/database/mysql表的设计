面试官:讲讲mysql表设计要注意啥
https://www.cnblogs.com/rjzheng/p/11174714.html
具体有下面这些问题

1、为什么一定要设一个主键？
2、你们主键是用自增还是UUID?
3、主键为什么不推荐有业务含义?
4、表示枚举的字段为什么不用enum类型？
5、货币字段用什么类型?
6、时间字段用什么类型?
7、为什么不直接存储图片、音频、视频等大容量内容?
8、字段为什么要定义为NOT NULL?

我用mysql只用过innodb存储引擎，其他的引擎真没用过。因此我的回答，都是基于innodb存储引擎中的。

问题1:为什么一定要设一个主键？
	回答:因为你不设主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。所以啦，反正都要生成一个主键，
	那你还不如自己指定一个主键，在有些情况下，就能显式的用上主键索引，提高查询效率！

问题2:主键是用自增还是UUID?
	回答:肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，
	记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。
	如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！
	大白话一句就是:用自增插入性能好！
	当主键是UUID的时候，插入时间更长，而且占用空间更大！

问题3:主键为什么不推荐有业务含义?
	回答:有如下两个原因
		(1)因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。
		主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。
		(2)带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面
		插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，
		就有可能引发页分裂，产生空间碎片。

问题4:表示枚举的字段为什么不用enum类型？
	回答:在工作中表示枚举的字段，一般用tinyint类型。
	那为什么不用enum类型呢？下面两个原因
		(1)ENUM类型的ORDER BY操作效率低，需要额外操作
		(2)如果枚举值是数值，有陷阱
			mysql> INSERT INTO test VALUES (1);
			查询出的结果为：0
			插入语句应该像下面这么写，插入的才是1
			mysql> INSERT INTO test VALUES (`1`);

问题5:货币字段用什么类型?
	回答:如果货币单位是分，可以用Int类型。如果坚持用元，用Decimal。
		千万不要答float和double，因为float和double是以二进制存储的，所以有一定的误差。
		float和double进行运算的时候会有误差

问题6:时间字段用什么类型?
	回答:此题无固定答案，应结合自己项目背景来答！把理由讲清楚就行！
	自己遇到的都是用的datetime，因为业务不涉及到时区和国际化
	(1)varchar，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没
		有校验，你可能某天就发现一条数据为2013111的数据，请问这是代表2013年1月11日，还是2013年11月1日？
		其次，做时间比较运算，你需要用STR_TO_DATE等函数将其转化为时间类型，
		你会发现这么写是无法命中索引的。数据量一大，是个坑！
	(2)timestamp，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。
		2038年以后的时间，是无法用timestamp类型存储的。但是它有一个优势，timestamp类型是带有时区信息的
		一旦你系统中的时区发生改变，例如你修改了时区SET TIME_ZONE = "america/new_york";
		你会发现，项目中的该字段的值自己会发生变更。
	(3)datetime，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。
		显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。
		如果你改变数据库的时区，该项的值不会自己发生变更！
	(4)bigint，也是8个字节，自己维护一个时间戳，表示范围比timestamp大多了，就是要自己维护，不大方便。

问题7:为什么不直接存储图片、音频、视频等大容量内容?
	回答:我们在实际应用中，都是用HDFS来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字
	段类型被用来设计存放大容量文件，也就是text和blob类型。但是，生产中，基本不用这两个类型！
	主要原因有如下两点：
		(1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，
		就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢
		(2)binlog内容太多。因为你数据内容比较大，就会造成binlog内容比较多。
		大家也知道，主从同步是靠binlog进行同步，binlog太大了，就会导致主从同步效率问题！

问题8:字段为什么要定义为NOT NULL?
	回答:OK，这问题从两个角度来答
	(1)索引性能不好
		Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，
		还需要mysql内部进行特殊处理，可空列被索引后，每条记录都需要一个额外的字节，还能导致
		MYisam 中固定大小的索引变成可变大小的索引。—— 出自《高性能mysql第二版》
	(2)查询会出现一些不可预料的结果




==========================================================================================
面试官:谈谈你对mysql联合索引的认识？
https://www.cnblogs.com/rjzheng/p/12557314.html
本文预计分为两个部分:
(1)联合索引部分的基础知识
在这个部分，我们温习一下联合索引的基础
(2)联合索引部分的实战题
在这个部分，列举几个我认为算是实战中的代表题，挑出来说说。

最左匹配
	所谓最左原则指的就是如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，值得注意的是，
	当遇到范围查询(>、<、between、like)就会停止匹配。(范围后面的不能用索引)

例如
而你对(a,b,c,d)建立索引,where后条件为
a = 1 and b = 2 and c > 3 and d = 4
那么，a,b,c能用到索引（注意c可以），而d就匹配不到。因为遇到了范围查询！（范围后面的不能用索引）

对(a,b)字段建立索引
则按照a来进行排序，在a相等的情况下，才按b来排序。

实战：
SELECT * FROM table WHERE a = 1 and b = 2 and c = 3;
此题正确答法是，(a,b,c)或者(c,b,a)或者(b,a,c)都可以	，重点要的是将区分度高的字段放在前面

SELECT * FROM table WHERE a > 1 and b = 2;
此题正确答法是，对(b,a)建立索引。
如果对(b,a)建立索引那么两个字段都能用上，优化器会帮我们调整where后a,b的顺序，让我们用上索引。

SELECT * FROM `table` WHERE a > 1 and b = 2 and c > 3;
(b,a)或者(b,c)都可以，要结合具体情况具体分析。

SELECT * FROM `table` WHERE a = 1 ORDER BY b;
一看就是对(a,b)建索引，当a = 1的时候，b相对有序，可以避免再次排序！

SELECT * FROM `table` WHERE a > 1 ORDER BY b;
对(a)建立索引，因为a的值是一个范围，这个范围内b值是无序的，没有必要对(a,b)建立索引。

SELECT * FROM `table` WHERE a IN (1,2,3) and b > 1;
还是对(a，b)建立索引，因为IN在这里可以视为等值引用，不会中止索引匹配，所以还是(a,b)!




