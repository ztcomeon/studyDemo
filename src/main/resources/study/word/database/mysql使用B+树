为什么Mongodb索引用B树，而Mysql用B+树?
https://www.cnblogs.com/rjzheng/p/12316685.html
B树和B+树

B树和B+树的数据结构特点决定了他们各自的优势和用途

B树
	树内的每个节点都存储数据
	叶子节点之间无指针相邻

B+树
	数据只出现在叶子节点
	所有叶子节点增加了一个链指针

针对上面的B+树和B树的特点，我们做一个总结
	(1)B树的树内存储数据，因此查询单条数据的时候，B树的查询效率不固定，最好的情况是O(1)。
	我们可以认为在做单一数据查询的时候，使用B树平均性能更好。但是，由于B树中各节
	点之间没有指针相邻，因此B树不适合做一些数据遍历操作。

	(2)B+树的数据只出现在叶子节点上，因此在查询单条数据的时候，查询速度非常稳定。
	因此，在做单一数据的查询上，其平均性能并不如B树。但是，B+树的叶子节点上有指针进行相连，
	，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做范围查询。

因此，我们可以做一个推论:没准是Mysql中数据遍历操作比较多，所以用B+树作为索引结构。
而Mongodb是做单一查询比较多，数据遍历操作比较少，所以用B树作为索引结构。

那么为什么Mysql做数据遍历操作多？而Mongodb做数据遍历操作少呢？
因为Mysql是关系型数据库，而Mongodb是非关系型数据。

那为什么关系型数据库，做数据遍历操作多？而非关系型数据库做数据遍历操作少呢？
关系型数据库：
在关系型数据库中，考虑的是用几张表来表示这二者之间的实体关系。常见关系：一对一，多对一，多对多
非关系型数据库：
表的设计上是不考虑表之间的关系的，他的查询是一种单一数据查询

因此，由于关系型数据库和非关系型数据的设计方式上的不同。
导致在关系型数据中，遍历操作比较常见，因此采用B+树作为索引，比较合适
而在非关系型数据库中，单一查询比较常见，因此采用B树作为索引，比较合适。

=============================================================================
小说:我是一条DQL
https://www.cnblogs.com/rjzheng/p/10668894.html
SQL执行流程图如下	大体如下
《高性能Mysql》
1.客户端/服务器，通信协议，提交SQL
2.查询缓存（命中返回结果，不命中的话往下执行）
3.进入分析器（解析器+预处理器）解析sql，预处理sql
4.进入查询优化器，优化sql
5.执行计划，查询执行引擎 API接口查询（myisam，innodb）查询数据
6.返回结果，进行缓存

DML(Update、Insert、Delete),DDL(表结构修改),DCL(权限操作),DQL(Select)操作

第一章 我和查询缓存的那些事
查询缓存，它其实是一个哈希表，它将执行过的语句及其结果会以 key-value 对的形式，被直接缓存在内存中。
它的key是一个哈希值，是通过查询SQL(也就是我)、当前要查询的数据库、客户端协议版本等，生成的一个哈希值
而它的value自然就是查询结果啦。

绕过查询缓存，也很简单。我可以像下面这么写:
	Select SQL_NO_CACHE * from table
	可以将参数query_cache_type设置成DEMAND来绕过查询缓存。

Mysql8.0版本开始淘汰查询缓存，大概是使用场景过于局限
	只要有对一个表的更新，这个表上所有的查询缓存都会被清空
	SQL任何字符上的不同,如空格,注释,都会导致缓存不命中

第二章 我和分析器的爱恨情仇
(本文将解析器和预处理器统一称为分析器)
解析器：解析sql语法，判断是否满足语法要求
预处理器：检查列名，表名是否存在，做权限验证

第三章 我和优化器的动人过往
优化器：能够优化sql，比如连表的顺序

第四章 我和执行器的悲情经历
执行器：就是根据执行计划来进行执行查询，根据指令，逐条调用底层存储引擎，逐步执行

如果是SELECT类型的SQL，Mysql会将查询结果缓存起来。至于其他的SQL，就将
该表涉及到的查询缓存清空。







