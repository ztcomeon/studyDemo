
索引原理
自增主键用完后怎么办
=========================================
MySQL(Innodb)索引的原理

索引的科普
先引进聚簇索引和非聚簇索引的概念！
创建的索引，如复合索引、前缀索引、唯一索引，都是属于非聚簇索引，在有的书籍中，又将其称为辅助索引(secondary
index)。在后文中，我们称其为非聚簇索引，其数据结构为B+树。

这个聚簇索引，在Mysql中是没有语句来另外生成的。在Innodb中，Mysql中的数据是按照主键的顺序来存放的。
那么聚簇索引就是按照每张表的主键来构造一颗B+树，叶子节点存放的就是整张表的行数据。
由于表里的数据只能按照一颗B+树排序，因此一张表只能有一个聚簇索引。
在Innodb中，聚簇索引默认就是主键索引。

没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引
如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

自增主键和uuid作为主键：
由于主键使用了聚簇索引，如果主键是自增id，，那么对应的数据一定也是相邻地存放在磁盘上的，写入性能比较高。
如果是uuid的形式，频繁的插入会使innodb频繁地移动磁盘块，写入性能就比较低了。

索引原理介绍
分为上下两个部分，上半部分是由主键形成的B+树，下半部分就是磁盘上真实的数据！那么，当我们， 执行下面的语句
select * from table where pId='11'
如上图所示，从根开始，经过3次查找，就可以找到真实数据。如果不使用索引，那就要在磁盘上，进行逐行扫描，直到找到数据位置
显然，使用索引速度会快。但是在写入数据的时候，需要维护这颗B+树的结构，因此写入性能会下降！

接下来引入非聚簇索引!我们执行下面的语句
create index index_name on table(name);

大家注意看，会根据你的索引字段生成一颗新的B+树。因此， 我们每加一个索引，就会增加表的体积， 占用磁盘存储空间。
然而，注意看叶子节点，非聚簇索引的叶子节点并不是真实数据，它的叶子节点依然是索引节点，
存放的是该索引字段的值以及对应的主键索引(聚簇索引)。如果我们执行下列语句
select * from table where name='lisi'
通过上图红线可以看出，先从非聚簇索引树开始查找，然后找到聚簇索引后。根据聚簇索引，在聚簇索引的B+树上，找到完整的数据！

什么情况不去聚簇索引树上查询呢？
还记得我们的非聚簇索引树上存着该索引字段的值么。如果，此时我们执行下面的语句
select name from table where name='lisi'
如上图红线所示，如果在非聚簇索引树上找到了想要的值，就不会去聚簇索引树上查询。

还记得，博主在《select的正确姿势》提到的索引问题么：
当执行select col from table where col = ?，col上有索引的时候，
效率比执行select * from table where col = ? 速度快好几倍！
原因就是上面的

那么这个时候，我们执行了下述语句，又会发生什么呢？
create index index_birthday on table(birthday);
看到了么，多加一个索引，就会多生成一颗非聚簇索引树。
因为，有几个索引，就有几颗非聚簇索引树！你在做插入操作的时候，需要同时维护这几颗树的变化！
因此，如果索引太多，插入性能就会下降!


===============================================================
杂谈自增主键用完了怎么办
https://www.cnblogs.com/rjzheng/p/10669043.html
采用自增主键，数据在物理结构上是顺序存储，性能最好...

如果int用完，可以改为bigInt，但是实际是不会用完的，数据量大的时候，会优先考虑分库分表，
此时数据的唯一标示就不能是自增的id了

我们先明白一点，在mysql中，Int整型的范围如下
Int(有符号)	-2147483648	2147483648	4 bytes
Int(无符号)	0			4294967295	4 bytes
我们以无符号整型为例，存储范围为0～4294967295，约43亿！
我们先说一下，一旦自增id达到最大值，此时数据继续插入是会报一个主键冲突异常如下所示
//Duplicate entry '4294967295' for key 'PRIMARY'

那解决方法也是很简单的，将Int类型改为BigInt类型，BigInt的范围如下
BigInt(有符号)	-9223372036854775808	9223372036854775808		8 bytes
BigInt(无符号)	0						18446744073709551615	8 bytes
因此你将自增ID设为BigInt类型，你是不用考虑自增ID达到最大值这个问题！

怎么改
目前业内在线修改表结构的方案，据我了解，一般有如下三种
方式一:使用mysql5.6+提供的在线修改功能
	所谓的mysql自己提供的功能也就是mysql自己原生的语句，例如我们要修改原字段名称及类型。
	mysql> ALTER TABLE table_name CHANGE old_field_name new_field_name field_type;

	那么，在mysql5.5这个版本之前，这是通过临时表拷贝的方式实现的。
	执行ALTER语句后，会新建一个带有新结构的临时表，将原表数据全部拷贝到临 时表，
	然后Rename，完成创建操作。这个方式过程中，原表是可读的，不可写。但是会消耗一倍的存储空间。
	在5.6+开始，mysql支持在线修改数据库表，在修改表的过程中，对绝大部分操作*，原表可读，也可以写。
	那么，对于修改列的数据类型这种操作，原表还能写么？
	如图所示，对于修改数据类型这种操作，是不支持并发的DML操作！也就是说，如果你直接使用
	ALTER这样的语句在线修改表数据结构，会导致这张表无法进行更新类操作(DELETE、UPDATE、DELETE)。
	因此，直接ALTER是不行滴！
	那我们只能用方式二或者方式三

方式二:借助第三方工具
	业内有一些第三方工具可以支持在线修改表结构，使用这些第三发工具，能够让你在执行ALTER操作的时候，
	表不会阻塞！比较出名的有两个
		1、pt-online-schema-change，简称pt-osc
		2、GitHub正式宣布以开源的方式发布的工具，名为gh-ost

		以pt-osc为例，它的原理如下
		1、创建一个新的表，表结构为修改后的数据表，用于从源数据表向新表中导入数据。
		2、创建触发器，用于记录从拷贝数据开始之后，对源数据表继续进行数据修改的操作记录下来，
			用于数据拷贝结束后，执行这些操作，保证数据不会丢失。
		3、拷贝数据，从源数据表中拷贝数据到新表中。
		4、rename源数据表为old表，把新表rename为源表名，并将old表删除。
		5、删除触发器。


	然而这两个有意(KENG)思(B)的工具，如果你的表里有触发器和外键，这两个工具是不行滴！
	如果真碰上了数据库里有触发器和外键，

方式三:改从库表结构，然后主从切换
	此法极其麻烦，需要专业水平的选手进行操作。因为我们的mysql架构一般是读写分离架构，从机是用来读的。
	我们直接在从库上进行表结构修改，不会阻塞从库的读操作。改完之后，进行主从切换即可。
	唯一需要注意的是，主从切换过程中可能会有数据丢失的情况！

假设啊，你的表里的自增字段为有符号的Int类型的，也就是说，你的字段范围为-2147483648到2147483648
一切又那么刚好，你的自增ID是从0开始的，也就是说，现在你的可以用的范围为0～2147483648。
我们明确一点，表中真实的数据ID，肯定会出现一些意外，ID不一定是连续的。例如，有如下情形的出现
	insert into t values(null);
	// 插入的行是 (1)
	begin;
	insert into t values(null);
	rolllack;
	insert into t values(null);
	// 插入的行是 (3)
因此，表中的真实id必然会出现断续的情况。
那这会你的自增主键id的数据范围为0～2147483648，也就是单表21亿条数据！
考虑id会出现断续，真实数据顶多18亿条吧。
都单表18亿条了，还不分库分表？你一旦分库分表了，就不能依赖于每个表的自增ID来全局唯一标识这些数据了。
此时，我们就需要提供一 个全局唯一的ID号生成策略来支持分库分表的环境。
因此在实际中，你根本等不到自增主键用完到情形！

所以，专业版回答如下
面试官:"那自增主键达到最大值了，用完了怎么办？"
你:"这问题没遇到过，因为自增主键一般用int类型，一般达不到最大值，我们就分库分表了，所以不曾遇见过！"
















