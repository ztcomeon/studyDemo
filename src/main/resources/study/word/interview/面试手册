
======================================================================================
java OOP（面向对象） 基础
13.什么是隐式转换，什么是显式转换
    显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；（由大转小 强转）
    隐式转换就是大范围的变量能够接受小范围的数据；（由小转大 自动转）
    隐式转换和显式转换其实就是自动类型转换和强制类型转换

19.面向对象的特征有哪些方面?
    抽象，封装，继承，多态
    多态性：
    多态性是指允许 不同子类型的对象 对同一消息 作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不
    同的事情。
    多态性分为  编译时的多态性  和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以
    解释为：当 A 系统访问 B 系统提供的服务时，B系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须
    刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B
    类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。
    方法重载（overload）实现的是编译时的多态性（也称为前绑定），
    方法重写（override）实现的是运行时的多态性（也称为后绑定）。
    运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：
    1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
    2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）

20.访问修饰符 public,private,protected,以及不写（默认） 时的区别
    protect：同包：能，    子类：能
    default：同包：能，    子类：不能

39.Java中各种数据默认值
    字符型(char)的基本类型变量的默认为 “/u0000”。

43.java中是值传递引用传递？
    java只有值传递（注意手册上的说法有问题）
    如果参数是基本类型，传递的是基本类型的字面量值的拷贝。
    如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。

71.JDBC操作的步骤
    1.加载数据库驱动类  （驱动）
    2.打开数据库连接    （连接）
    3.执行sql          （执行）
    4.处理返回结果      （处理）
    5.关闭资源          （关闭）

74.是否了解连接池，使用连接池有什么好处
    数据库的连接很消耗资源，连接池用来分配，管理，释放数据库连接，可以使应用程序重复使用同一个数据库连接，
    而不是很次都创建一个新的连接，通过释放空闲时间较长的数据库连接，避免数据库因创建太多的连接，而造成连接
    遗漏的问题，提高程序性能

77.静态内部类如何定义
    其他类使用静态内部类需要使用“外部类.静态内部类”方式，如：Out.Inner inner=new Out.Inner(); inner.print();
    java集合类HashMap内部就有一个静态内部类Entry，Entry是hashmap存放元素的抽象，hashmap内部维护entry数组用来
    存放元素，但是entry对使用者是透明的，像这种和外部类关系密切，且外部类实例的，可以使用静态内部类

78.什么是成员内部类
    定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final修饰的除外）。
    这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，
    那么成员内部类的静态变量初始化顺序是有歧义的

92.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？
    不对，（前提是hashcode和equals都重写了），equals相同则hashcode一定相同，hashcode相同equals不一定相同

103.如何实现对象克隆？
    有两种方式：
    1.实现 Cloneable 接口并重写 Object 类中的 clone()方法；
    2.实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真

===================================================================================================
java集合/泛型面试题



===================================================================================================
java异常面试题
4.try catch finally，try里有return，finally还执行么？
    执行，并且finally的执行早于try里面的return
    结论：
    1.不管有木有出现异常，finally块中代码都会执行；
    2.当try和catch中有return时，finally仍然会执行；
    3.finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally
       中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
    4.finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值

6.throw与throws区别
    位置不同:
        throws 用在函数（方法）上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的是异常对象
    功能不同：
        1.throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；
        throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。
        也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。
        2.throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，
        执行 throw 则一定抛出了某种异常对象。
        3.两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异
        常，真正的处理异常由函数的上层调用处理。
======================================================================================
多线程并发
14、Java中interrupted 和 isInterrupted方法的区别？
    https://www.cnblogs.com/xrq730/p/4856361.html
    interrupt()中断（执行中断，只是改变线程的一个标志位），isInterrupted（）是否中断（只判断），
    interrupted（）判断是否已经中断，并且清除中断标识位（判断+清楚）

17.SynchronizedMap和ConcurrentHashMap有什么区别？


衍生的问题：
    面试题：ConcurrentHashMap 1.7和1.8的区别
    https://blog.csdn.net/u013374645/article/details/88700927

    美团面试题：Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析
    https://blog.csdn.net/qq_36520235/article/details/82417949

    面试阿里，HashMap 这一篇就够了
    https://blog.csdn.net/v123411739/article/details/106324537

32.终止线程 4 种方式
    正常运行结束，使用退出标志退出线程，Interrupt 方法结束线程，stop 方法终止线程（线程不安全）
    注意：Interrupt 方法结束线程：
        1.线程处于阻塞状态：此时调用interrupt（）方法时，会抛出InterruptException异常，捕获这个异常，然后
            break跳出循环，结束线程
        2.线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。

50.偏向锁
    同一个线程多次获取锁（多次执行同步代码块）的情况下，偏向锁的目的是，某个线程获得锁之后，消除这个线程锁重入的开销
    （因为很多情况下，是不存在锁竞争的，只有一个线程执行同步代码块）
    无多线程竞争的情况下，尽量减少不必要的轻量级锁的执行路径，轻量级的锁的获取和释放需要多次CAS原子指令

    轻量级锁：
    适用场景是，线程 交替执行 同步块 的情况下能够提升性能 （没有多线程竞争的前提下，减少传统的重量级锁产生的性能损耗）

    重量级锁：
    synchronize通过对象内部的监视器（monitor）来实现，监视器又和底层的操作系统的mutex lock来实现的
    操作系统实现线程的切换，就需要从用户态转换到核心态，代价比较高，JDK对其进行了优化，
    JDK1.6之后有引入轻量级锁和偏向锁，
    锁升级：无锁状态->偏向锁（同一线程同步代码）->轻量级锁（不同线程交替执行同步代码）->重量级锁

52.锁优化
   减少锁的持有时间，减少锁的粒度（ConcurrentHashMap），锁分离（ReadWriteLock分为读锁和写锁），
   锁粗化（同一个线程不停的请求同步和释放），锁消除（编译时发现不可能被共享的对象可以消除这些对象上的锁）

56.yield（）方法：只释放CPU资源，不会释放锁

58.Join（）方法，等待其他线程的终止，比如在主线程中调用thread1.join();在主线程需要等thread1结束后才能执行

88.死锁，活锁，饥饿
    死锁：多线程竞争资源，造成相互等待，没有外力无法推进
    活锁：任务或者执行者没有被阻塞，但是某些条件没有满足，就一直尝试，失败，尝试，失败（类似互相谦让导致都无法执行）
    饥饿：线程无法获得某种所需要的资源，导致一直是无法执行状态


==================================================================================
spring相关：
5.spring的模块
    1.spring的核心模块：core，bean,el,context
    2.数据访问和集成：JDBC.ORM.OXM,JMS,Transactions
    3.web模块：web，servlet，socket，portlet
    4.AOP，Test等模块

13.spring中有多少中容器：
    1.BeanFactory：基础类型的Ioc容器，提供完整的Ioc服务支持
    2.ApplicationContext：BeanFactory的子接口，在 BeanFactory 的基础上构建，是相对比较高级的Ioc容器，
        包含 BeanFactory 的所有功能，还提供了其他高级特性，事件发布，国际化信息支持， 同一资源加载策略等

21.什么是spring的内部bean
    将bean作为另一个bean的属性时，才能将bean声明为内部bean

30.@Qualifier
    有多个相同类型的bean时，指定装配哪一个

===================================================================================
redis相关：
8.一个字符串类型的值能存储最大容量是多少
    官方给出来的是512M

16.为什么Redis的操作是原子性的，怎么保证原子性的？
    对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。
    Redis的操作之所以是原子性的，是因为Redis是单线程的。
    Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。
    多个命令在并发中也是原子性的吗？
    不一定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua==的方式实现。

17.Redis事务
    Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的（multi，exec，）
    Redis会将一个事务中的所有命令序列化，然后按顺序执行。
    1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
    2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行；
    3.如果在一个事务中出现运行错误，那么正确的命令会被执行。
    1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会
    立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
    2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值
    3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出
    4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改
    （或删除），之后的事务就不会执行，监控一直持续到EXEC命令

25.是否使用过 Redis 集群，集群的原理是什么？
    1.Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为master，继续提供服务。
    2.Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。

30.说说 Redis 哈希槽的概念？
    Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验
    后对16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽

37.怎么理解 Redis 事务？
    1.事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的
    命令请求所打断。    MULTI、EXEC、DISCARD、WATCH
    2.事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行

========








