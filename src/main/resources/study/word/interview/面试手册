
=======
多线程并发
14、Java中interrupted 和 isInterrupted方法的区别？
https://www.cnblogs.com/xrq730/p/4856361.html
interrupt()中断（执行中断，只是改变线程的一个标志位），isInterrupted（）是否中断（只判断），
interrupted（）判断是否已经中断，并且清除中断标识位（判断+清楚）

17.SynchronizedMap和ConcurrentHashMap有什么区别？


衍生的问题：
    面试题：ConcurrentHashMap 1.7和1.8的区别
    https://blog.csdn.net/u013374645/article/details/88700927

    美团面试题：Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析
    https://blog.csdn.net/qq_36520235/article/details/82417949

    面试阿里，HashMap 这一篇就够了
    https://blog.csdn.net/v123411739/article/details/106324537

32.终止线程 4 种方式
    正常运行结束，使用退出标志退出线程，Interrupt 方法结束线程，stop 方法终止线程（线程不安全）
    注意：Interrupt 方法结束线程：
        1.线程处于阻塞状态：此时调用interrupt（）方法时，会抛出InterruptException异常，捕获这个异常，然后
            break跳出循环，结束线程
        2.线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。

50.偏向锁
    同一个线程多次获取锁（多次执行同步代码块）的情况下，偏向锁的目的是，某个线程获得锁之后，消除这个线程锁重入的开销
    （因为很多情况下，是不存在锁竞争的，只有一个线程执行同步代码块）
    无多线程竞争的情况下，尽量减少不必要的轻量级锁的执行路径，轻量级的锁的获取和释放需要多次CAS原子指令

    轻量级锁：
    适用场景是，线程 交替执行 同步块 的情况下能够提升性能 （没有多线程竞争的前提下，减少传统的重量级锁产生的性能损耗）

    重量级锁：
    synchronize通过对象内部的监视器（monitor）来实现，监视器又和底层的操作系统的mutex lock来实现的
    操作系统实现线程的切换，就需要从用户态转换到核心态，代价比较高，JDK对其进行了优化，
    JDK1.6之后有引入轻量级锁和偏向锁，
    锁升级：无锁状态->偏向锁（同一线程同步代码）->轻量级锁（不同线程交替执行同步代码）->重量级锁

52.锁优化
   减少锁的持有时间，减少锁的粒度（ConcurrentHashMap），锁分离（ReadWriteLock分为读锁和写锁），
   锁粗化（同一个线程不停的请求同步和释放），锁消除（编译时发现不可能被共享的对象可以消除这些对象上的锁）

56.yield（）方法：只释放CPU资源，不会释放锁

58.Join（）方法，等待其他线程的终止，比如在主线程中调用thread1.join();在主线程需要等thread1结束后才能执行

88.死锁，活锁，饥饿
    死锁：多线程竞争资源，造成相互等待，没有外力无法推进
    活锁：任务或者执行者没有被阻塞，但是某些条件没有满足，就一直尝试，失败，尝试，失败（类似互相谦让导致都无法执行）
    饥饿：线程无法获得某种所需要的资源，导致一直是无法执行状态





