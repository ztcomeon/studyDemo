
==================029========================================
1.项目介绍
2.hashmap为什么要重写hashcode和equals方法
3.迭代器，为什么要设计，为什么遍历的时候去删除是安全的
4.java集合排序常用的工具类
5.基本的泛型使用场景
6.spring事务传播机制
7.spring注解失效的场景
=================024=================
1.自我介绍，项目核心模块
2.stringbuffer和Stringbuilder
3.jdk1.8新特性
4.jdk1.8流语法常用的哪些功能
5.Java比较元素实现的接口，排序
6.spring的bean默认是单例的吗，为什么是单例的
7.项目中运用多线程的场景，核心参数配置
8.遇到的生产问题，独立解决的
====================022=============
1.自我介绍，项目核心模块
2.string类为什么的final类型的
3.hashmap底层原理和实现结构
4.内存泄漏的问题怎么定位
5.springmvc的原理
6.spring事务管理
7.多线程里start方法和run方法区别
8.java线程池的原理
9.数据库用过悲观锁和乐观锁吗
10.项目里用到什么设计模式
11.系统在高并发情况下，对这种场景有什么设计吗
================019======================
测试开发
业务模型描述说不清楚，业务描述能力弱，项目简单，项目交互不清楚，db关心不够
项目偏性能，手工/自动化项目经验不够
需要基本的编码能力，自动化用例，跑接口数据
==================016================
1.自我介绍，项目核心模块
2.定时任务重复执行多次
3.spring事务
4.注解事务失效情况
5.接口调用数据有幂等性，然后如何设计
6.项目里面AOP开发过什么功能
7.哪些场景用到过枚举
8.哪些地方用到过泛型
9.java里面的锁有哪些地方用到过
10.生成上面的问题如何排查，常见的命令
===================010=====================
1.项目为什么用springcloud
2.springboot和springcloud区别
3.springcloud限流使用哪个组件
4.微服务里如何防止重复请求（幂等性问题）
5.请求一些接口，出现异常时怎么设计的
6.单例模式说几个
7.消息队列里怎么保证数据不重复
8.redis缓存和数据库mysql数据一般不一致的话怎么解决
9.hashMap中的hashcode作用
10.生产中解决比较复杂的问题怎么定位解决的
===================008=============
1.oracle中的存储过程怎么调试的
2.接口开发
3.打日志是通过什么打的，有什么规范
4.集合排序的工具类
5.内存溢出怎么回事
6.session和cookie区别
7.线程池原理，核心模块
8.生产排查问题使用哪些linux命令
9.数据库里乐观锁，怎么实现，悲观锁，怎么实现
10.sringmvc简单流程
===================007================================
1.多线程的同步实现方法
2.hashcode作用
3.异常err和exception的区别
4.redis缓存实际应用的场景和数据类型
5.springAOP实际应用
6.数据库索引失效的场景
7.数据库表根据什么条件去创建索引
======================101=========================================
深圳培训后面试的个拿4个，培训机构提供面试题，背诵，模拟面试
市场上流行的面试题
===============006==================
1.支付流程操作了哪些表
2.遇到哪些生产问题
3.方法的重载和重写
4.如何实现线程同步
5.final修饰类时，里面的属性能修改吗
6.i++是线程安全的吗，什么情况下安全
7.sql优化，从哪几方面去考虑，具体怎么做
=================005======================
1.rabbitmq如何保证消息不丢失
2.redis数据类型，和应用场景介绍一下
3.模板设计模式，项目有用到吗，介绍一下
4.maven依赖包冲突如何解决
5.分布式的确定
6.分表，业务主键的设计
=================004===========
1.信用卡系统和银行接口消息交互，具体介绍一下，如何依赖，加密消息格式，异常定义
2.hashMap的key存对象时，需要注意什么
3.hashmap中的hashcode是干嘛的
4.异常有哪几类，分别是怎么用的
5.接口联调的具体案例怎么解决的
=================001=================
1.sring，sringbuffer，stringbuilder区别
2.jdk1.8hashmap内部存储结构
3.集合为什么要设计出迭代器
4.单机环境下，并发控制，java有哪些手段
5.多线程创建的方式哪几种
6.服务器端如何防止表单重复提交原理
7.springaop的原理大概介绍一下
8.mysql批量导入1千万条数据，如何做
9.项目中打日志的框架，错误日志具体怎么配置的


答案集合
=====================================================================
=========================029============================================
1.项目介绍
	1 业务的全链路逻辑清晰都表达出来（大概流程）
	2 一定把技术的亮点展示出来
	3 功能的设计思路,如表设计 设计模式的应用

	项目亮点吧：
		1.技术框架必须包含的，SSM、缓存（redis，memcached）、MQ、微服务，前提你必须真用过
		2.复杂业务，你只有简单的CRUD也没关系，面试初级程序员可以的
		3.并发多线程场景，这是加分项，spring线程池怎么用啊，多线程什么场景里用啊，说的非常清楚，必须
		4.第三方接口调用，如调用银行接口，里面关于异常怎么定义啊，失败机制、重试机制、幂等
		5.代码的优雅设计，项目中用了模板啊、单例、高级泛型啊、异常设计、日志啊、拦截器啊、自定义注解
		6.java8新特性，如java流式语法出来好久了，你用过能给面试官说说他的好处及常见的方法，必须加分


2.hashmap为什么要重写hashcode和equals方法
	数组+链表（+红黑树jdk1.8）组成
	hashcode用来确定key所在的位置，equals用来比较位置上的内容是否相等的
	计算键的hashcode作为数组下标，用于查找键对象的存储位置

3.迭代器，为什么要设计，为什么遍历的时候去删除是安全的
	集合较多，数据容器的操作有极大的共性，所以java采用的迭代器为各种容器提供公共的接口
	达到一种解耦效果，迭代器iterator可以使对容器的遍历操作完全与其底层相隔离
	遍历集合时删除特定元素一定要用Iterator的remove,别用集合自带的remove，不然会报错

	关于集合修改:
		ConcurrentModificationException  （修改异常的情况）
		集合内部维护一个modCount记录集合被修改的次数，每当集合内部结构发生变化的时候，modCount+1
		迭代器内部也维护一个字段exceptedModCount，同样记录当前集合的修改次数，初始化为集合的modCount值。
		当我们在调用Iterator进行遍历操作时，如果有其他线程修改list会出现modCount!=expectedModCount的
		情况，就会报并发修改异常
	记住五个单词：
	Iterator
	remove
	modCount
	expectedModCount
	ConcurrentModificationException

4.java集合排序常用的工具类
	Collections.sor(List list)
	Collections.sor(List list,,Comparator c)

5.基本的泛型使用场景
	具体类型--->参数化(泛型化)
	泛型，即“参数化类型”。例如定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？
	就是将类型由原来的具体的类型，参数化，类似于方法中的变量参数，此时类型也定义成参数形式
	（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

	泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制
	的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在
	类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

	java中的泛型主要使用在类，方法，与接口中。
	优点: 不用每个结果对象上定义错误码等属性,设计变优雅啦
	代码复用效果杠杠的
	泛型类型参数作用于类上的时候主要是对多个字段及方法签名之间的类型约束。
	作用于方法的时候主要是对方法的的多个参数做相应的约束，在这里方法的泛型类型参数不再举例，


6.spring事务传播机制
	注解配置时如：@Transactional(propagation=Propagation.REQUIRED)
	 事务注解基本99%情况都是默认的(REQUIRED默认)
	七种：required,supports,mandatory,requiers_new,not_supported,never,nested
	REQUIRED（默认）支持使用当前事务，如果当前事务不存在，创建一个新事务。
	SUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。
	MANDATORY：中文翻译为强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。
	REQUIRES_NEW：创建一个新事务，如果当前事务存在，把当前事务挂起。
	NOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起
	NEVER：无事务执行，如果当前有事务则抛出Exception。
	NESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则跟REQUIRED一样


7.spring注解失效的场景
	事务失效3种常见原因:
		自身调用（面试最爱问啦）
		异常被吃
		异常抛出类型

	自身调用导致失败(不能够自身调用，必须使用代理类调用)
	@Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，
	再由这个代理对象来统一管理，当在Service实现类直接调用内部方法时，其本质是通过this对象来调用的方法，
	而不是代理对象，因为会出现事务失效的情况

	解决方法:	（思路：使用代理类调用事务的方法）
		1.把事务代码下沉,用一个类去单独处理(一个类调用另一个类)
		2.springboot：开始aop事务，启动类application加注解@EnableAspectJAutoProxy(exposeProxy
		= true)，((UserService)AopContext.currentProxy()).insertUser2();
		3.实现applicationContextAware ，获取代理类，然后用代理类去调用第二个事务
	（需要在去实践一下2,3）
=================024=================
1.自我介绍，项目核心模块
2.stringbuffer和Stringbuilder
	运行速度
	线程安全上
	适用场景

3.jdk1.8新特性
	前面这几个都有用过，后面两个在看一下
	Lambda表达式
	函数式接口
	Stream API
	新时间日期API
	接口中的默认方法和静态方法
	*方法引用和构造器调用

4.jdk1.8流语法常用的哪些功能
相关的学习链接
https://mp.weixin.qq.com/s?__biz=MzA4NzQ0Njc4Ng==&mid=2247484947&idx=1&sn=a0f080ec95b605d4a76b8a17effb5251&chksm=9038027ea74f8b68390669820f268085d77892295ca87eb9134212001a24838c0d250ab17f03&scene=21#wechat_redirect

https://mp.weixin.qq.com/s?__biz=MzA4NzQ0Njc4Ng==&mid=2247484903&idx=1&sn=004d5808924fb96282cdb6f5e0c170ad&chksm=9038018aa74f889cb09ba588abca3a9086ba96324a10d0fd03574f7de637f66805c62324704b&scene=21#wechat_redirect

https://mp.weixin.qq.com/s?__biz=MzA4NzQ0Njc4Ng==&mid=2247484908&idx=2&sn=295cc79cd2f5d2536c3ce889653997ee&chksm=90380181a74f8897ecd8ee02510321fab745eda58d876c73d4dc6658e0d485243b85b623d45a&scene=21#wechat_redirect


5.Java比较元素实现的接口，排序
	Arrays.sort()和Collections.sort()
	使用Comparable接口   Comparable接口定义了compareTo方法，用于对象之间的比较（实体类去实现这个接口）
	使用Comparator接口   Comparator可以用于比较没有实现Comparable的类的对象（自定义比较器）

6.spring的bean默认是单例的吗，为什么是单例的
	参考博客
	https://www.jianshu.com/p/4f852ec7ac8b
	单例：一个bean被声明为单例时，处理多次请求时spring容器里只实例化一个bean，后续的请求公用这个对象，
	这个对象存储在一个map中，当有请求时，先在缓存中（map）查找是否存在，存在则使用，不存在才实例化一个对象

	优点：
	1.少创建实例		新生成实例消耗包括两方面，第一，spring会通过反射或者cglib来生成bean实例这都是耗
							性能的操作，其次给对象分配内存也会涉及复杂算法。
	2.垃圾回收			由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。
	3.缓存快速获取		单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。

	缺点：
	在并发环境下线程不安全

	原型：每当有请求来就实例化一个新的bean，没有缓存以及从缓存中查


7.项目中运用多线程的场景，核心参数配置
	场景：案例一 大数据量查询【查】案例二，批量更新请求【更新】
	实际：excel导入企业数据（十几万条数据，数据量不大，但是单线程导入慢）使用线程池技术
		请大家不要滥用并发，上生产前一定要压测下，考虑机器资源DB资源等等是否充分利用


8.遇到的生产问题，独立解决的
	mybatis并发线程不安全问题，解决 升级mybatis版本
	利用线程池开发业务功能，但对多线程的无序性考虑不足，导致业务数据更新顺序出现问题（数据不一致了）
		解决方案 加上 同步标识ID,代码上判断 同步标识存在了标识处理过了
	折扣字段精度 使用double进行计算，精度缺失 改成BigDecimal
	NPE(空指针)，业务场景考虑不足，特定场景数据空了，但代码没考虑防空，这个问题非常低级但是出现频率最高，
		生产环境数据本来就很复杂，
	超时导致双方数据不一致，生产环境偶尔会出现超时情况，解决方案 人工数据订正，通过核对系统及时发现数据不一致问题

	遇到的生产问题：
	需要想一想：：：


====================022=============
1.自我介绍，项目核心模块
2.string类为什么的final类型的
	为了实现字符串池(只有当字符是不可变的，字符串池才有可能实现)
	为了线程安全(字符串自己便是线程安全的)
	为了实现String可以创建HashCode不可变性(Map的key一般String用的最多原因就是这个)

	被final修饰的类不能被继承，即它不能拥有自己的子类
	被final修饰的方法不能被重写
	final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作，一旦赋值不能进行修改

	String被final修饰：注意是 安全性 和 效率
	final修饰的对象只是引用地址不可变，内容还是能变的

3.hashmap底层原理和实现结构
	HashMap复习精讲
	https://www.cnblogs.com/rjzheng/p/11302835.html
	注意：数组+链表+(1.8增加了 红黑树，链表大于8转红黑树)

4.内存泄漏的问题怎么定位
	jmap，jstack 的使用等等，VisualVM一个idea的插件，安装后可视化的监控jvm
	https://blog.csdn.net/weixin_42867975/article/details/96733835  jmap相关的操作
	https://blog.csdn.net/mynamepg/article/details/81702075    jstack相关的操作

5.springmvc的原理
整个springmvc的流程

6.spring事务管理
见上

7.多线程里start方法和run方法区别
	1.用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码
		(可运行）状态,并没有运行，一旦得到cpu时间片，就开始执行run()方法
	2.这里方法run()称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止

	start方法可启动多线程
	run方法只是thread的一个普通方法调用，还是在主线程里执行，是不会开启多线程的

8.java线程池的原理
见上

9.数据库用过悲观锁和乐观锁吗
	乐观锁：访问的时候认为不用引起并发冲突（乐观），代码来控制，版本号version字段控制
	悲观锁：select ... for update

	乐观锁关键总结（不难理解但要用对地方）
		表设计version字段
		加事务，在事务内操作 version=version+1
		选择合适场景使用乐观锁
		业务例子工单提交，防止其他人并发提交，走乐观锁

	乐观锁宽入严出,乐观锁是非阻塞算法，悲观锁是阻塞算法
	悲观锁用的不好容易死锁，乐观锁用的不好结果就不可预期
	乐观锁加锁的时间要比悲观锁短，性能完胜悲观锁
	乐观锁看作是关于冲突检测的，那么悲观锁就是冲突避免

	悲观锁总结
		利用mysql的for update悲观锁来防并发，简单有效
		for update 切记后面要是索引的查询条件，如上唯一索引，select XXX where 唯一索引 for udpate
		业务代码中切记在事务代码中去操作
		特别是审批业务，都必须考虑并发情况

	不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，
	如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住（间隙锁+行锁）

	关于redis分布式锁
	https://mp.weixin.qq.com/s?__biz=MzA4NzQ0Njc4Ng==&mid=2247484803&idx=2&sn=96a4e7cff196bcc07504aafd7d2
	4622d&chksm=903801eea74f88f8ad6cda26606746f4a5a78bebfa556eb591f62aef11535b95a8b90121edd0&scene=21
	#wechat_redirect
	分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。

10.项目里用到什么设计模式



11.系统在高并发情况下，对这种场景有什么设计吗
================019======================
测试开发
业务模型描述说不清楚，业务描述能力弱，项目简单，项目交互不清楚，db关心不够
项目偏性能，手工/自动化项目经验不够
需要基本的编码能力，自动化用例，跑接口数据
==================016================
1.自我介绍，项目核心模块
2.定时任务重复执行多次
3.spring事务
4.注解事务失效情况
5.接口调用数据有幂等性，然后如何设计
6.项目里面AOP开发过什么功能
7.哪些场景用到过枚举
8.哪些地方用到过泛型
9.java里面的锁有哪些地方用到过
10.生成上面的问题如何排查，常见的命令
===================010=====================
1.项目为什么用springcloud
2.springboot和springcloud区别
3.springcloud限流使用哪个组件
4.微服务里如何防止重复请求（幂等性问题）
5.请求一些接口，出现异常时怎么设计的
6.单例模式说几个
7.消息队列里怎么保证数据不重复
8.redis缓存和数据库mysql数据一般不一致的话怎么解决
9.hashMap中的hashcode作用
10.生产中解决比较复杂的问题怎么定位解决的
===================008=============
1.oracle中的存储过程怎么调试的
2.接口开发
3.打日志是通过什么打的，有什么规范
4.集合排序的工具类
5.内存溢出怎么回事
6.session和cookie区别
7.线程池原理，核心模块
8.生产排查问题使用哪些linux命令
9.数据库里乐观锁，怎么实现，悲观锁，怎么实现
10.sringmvc简单流程
===================007================================
1.多线程的同步实现方法
2.hashcode作用
3.异常err和exception的区别
4.redis缓存实际应用的场景和数据类型
5.springAOP实际应用
6.数据库索引失效的场景
7.数据库表根据什么条件去创建索引
======================101=========================================
深圳培训后面试的个拿4个，培训机构提供面试题，背诵，模拟面试
市场上流行的面试题
===============006==================
1.支付流程操作了哪些表
2.遇到哪些生产问题
3.方法的重载和重写
4.如何实现线程同步
5.final修饰类时，里面的属性能修改吗
6.i++是线程安全的吗，什么情况下安全
7.sql优化，从哪几方面去考虑，具体怎么做
=================005======================
1.rabbitmq如何保证消息不丢失
2.redis数据类型，和应用场景介绍一下
3.模板设计模式，项目有用到吗，介绍一下
4.maven依赖包冲突如何解决
5.分布式的确定
6.分表，业务主键的设计
=================004===========
1.信用卡系统和银行接口消息交互，具体介绍一下，如何依赖，加密消息格式，异常定义
2.hashMap的key存对象时，需要注意什么
3.hashmap中的hashcode是干嘛的
4.异常有哪几类，分别是怎么用的
5.接口联调的具体案例怎么解决的
=================001=================
1.sring，sringbuffer，stringbuilder区别
2.jdk1.8hashmap内部存储结构
3.集合为什么要设计出迭代器
4.单机环境下，并发控制，java有哪些手段
5.多线程创建的方式哪几种
6.服务器端如何防止表单重复提交原理
7.springaop的原理大概介绍一下
8.mysql批量导入1千万条数据，如何做
9.项目中打日志的框架，错误日志具体怎么配置的


























